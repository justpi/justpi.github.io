<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【剑指offer-2】基础知识</title>
    <link href="/2022/05/28/%E3%80%90%E5%89%91%E6%8C%87offer-2%E3%80%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/05/28/%E3%80%90%E5%89%91%E6%8C%87offer-2%E3%80%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h1><p>在面试过程中，面试官要么直接问语法，要么让用一种语言解决一个问题。在cpp中，一般考察编程语言的方式有以下三种：</p><ul><li>直接询问对cpp概念的理解：如cpp中的关键字，或者sizeof函数在各种情况下的值；</li><li>分析写好的代码</li><li>定义一个类型或实现类型中的成员函数</li></ul><h2 id="1赋值运算符函数"><a href="#1赋值运算符函数" class="headerlink" title="#1赋值运算符函数"></a>#1赋值运算符函数</h2><blockquote><p>题目：如下为类型CMyString的声明，请为该类型添加赋值运算符函数。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CMyString</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">CMyString</span>(<span class="hljs-type">char</span>* pData=<span class="hljs-literal">nullptr</span>);<br>        <span class="hljs-built_in">CMyString</span>(<span class="hljs-type">const</span> CMyString&amp; str);<br>        ~<span class="hljs-built_in">CMyString</span>(<span class="hljs-type">void</span>);<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">char</span>* m_pData;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在设计赋值运算符函数时需要考虑下面四个问题：</p><ul><li>返回值的类型声明与返回值：返回值的类型声明应该是该类型的引用，返回值应该是返回的实例自身的引用(*this)。考虑连续赋值的情况，如果函数返回值为空，不是返回的引用将不能连续赋值；</li><li>传入的参数类型：传入的参数应该是常量引用，因为如果传入的参数不是引用而是实例的话，那么从形参到实参会调用一次复制构造函数，一般参数传递时使用引用来代替实例和指针，可以避免无谓的消耗，提高代码的效率，另外由于我们在函数中不用改变传入实例的状态，所以使用const；</li><li>内存管理：是否释放实例自身已有的内存；</li><li>特殊输入判断：判断传入的参数和当前的实例(*this)是不是同一个实例；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">CMyString&amp; <span class="hljs-title">CMystring</span><span class="hljs-params">(<span class="hljs-type">const</span> CMyString &amp;str)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (*<span class="hljs-keyword">this</span> == &amp;str) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br><br>    <span class="hljs-keyword">delete</span> []m_pData;<br>    m_pData = <span class="hljs-literal">nullptr</span>;<br><br>    m_pData= <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str.m_pData) + <span class="hljs-number">1</span>]<br>    <span class="hljs-built_in">strcpy</span>(m_pData, str.m_pData);<br><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="cpp基础知识"><a href="#cpp基础知识" class="headerlink" title="cpp基础知识"></a>cpp基础知识</h3><blockquote><p><strong>引用</strong>：引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。我们一般在类型名后添加<code>&amp;</code>来表示。</p></blockquote><blockquote><p><strong>引用与指针的区别</strong>：不存在空引用。引用必须连接到一块合法的内存。一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。引用必须在创建时被初始化。指针可以在任何时间被初始化。</p></blockquote><blockquote><p><strong>this指针</strong>：在 C++ 中，每一个对象都能通过 this 指针来访问自己的地址。this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针。</p></blockquote><blockquote><p><strong>复制构造函数</strong>：拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于：通过使用另一个同类型的对象来初始化新创建的对象。复制对象把它作为参数传递给函数。复制对象，并从函数返回这个对象。</p></blockquote><blockquote><p><strong>形参与实参的区别</strong>：形参出现在函数定义的地方，多个形参之间以逗号分隔，形参规定了一个函数所接受数据的类型和数量。实参出现在函数调用的地方，实参的数量与类型与形参一样，实参用于初始化形参。当形参是引用类型时，对应的实参被引用传递，引用形参是对应的实参的别名。当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象，对应的实参被值传递。C++中，建议使用引用类型的形参替代指针，因为使用引用，形式上更简单，无须额外声明指针变量，也避免了拷贝指针的值。如果函数无须改变引用  形参的值，最好将其声明为const引用。</p></blockquote><blockquote><p><strong>指针运算符</strong>：C++ 提供了两种指针运算符，一种是取地址运算符<code>&amp;</code>，一种是间接寻址运算符<code>*</code>。<code>&amp;</code>是一元运算符，返回操作数的内存地址。第二个运算符是间接寻址运算符<code>*</code>，它是<code>&amp;</code>运算符的补充。<code>*</code>是一元运算符，返回操作数所指定地址的变量的值。</p></blockquote><hr><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><blockquote><p>剑指 Offer 03. 数组中重复的数字：在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p></blockquote><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：<br><span class="hljs-string">[2, 3, 1, 0, 2, 5, 3]</span><br>输出：<span class="hljs-number">2</span> 或 <span class="hljs-number">3</span> <br></code></pre></td></tr></table></figure><p>这个问题有三种解法，第一种是先将数组排序，然后从前往后遍历一遍即可找到重复的数，排序的时间复杂度为<code>O(nlogn)</code>；第二种是利用哈希表来解决时间和空间复杂度均为O(n)，如下，还可以进一步不用新建数组，直接在原始数组上交换元素并进行比较，空间复杂度可以到<code>O(1)</code>；第三种是使用二分查找的思想，分别统计前1~m和m+1~n中数字出现的次数$t_{1,m}$和$t_{m+1,n}$，若$t_{1,m} &gt; m$则前面的序列中存在重复数字，递归前面的子数组，后面的亦然如此，这种方法每次需要统计数字出现的次数，时间复杂度为<code>O(n)</code>，二分查找时间复杂度为<code>O(logn)</code>，总体时间复杂度为<code>O(nlogn)</code>，空间复杂度为<code>O(1)</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 解法二：数组作为哈希表，空间复杂度为O(n),时间复杂度为O(n)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">hash</span><span class="hljs-params">(nums.size(), <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            hash[nums[i]] ++;<br>            <span class="hljs-keyword">if</span> (hash[nums[i]] &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">测试用例：<br><span class="hljs-bullet">    -</span> 长度为n的数组里包含一个或多个重复的数字<br><span class="hljs-bullet">    -</span> 无效输入测试用例（空数组，包含0——n-1之外的数字）<br></code></pre></td></tr></table></figure><blockquote><p>剑指 Offer 04. 二维数组中的查找:在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">现有矩阵 matrix 如下：<br><span class="hljs-string">[</span><br><span class="hljs-string">  [1,   4,  7, 11, 15]</span>,<br><span class="hljs-string">  [2,   5,  8, 12, 19]</span>,<br><span class="hljs-string">  [3,   6,  9, 16, 22]</span>,<br><span class="hljs-string">  [10, 13, 14, 17, 24]</span>,<br><span class="hljs-string">  [18, 21, 23, 26, 30]</span><br>]<br><br>给定 target = <span class="hljs-number">5</span>，返回 <span class="hljs-literal">true</span>。<br><br>给定 target = <span class="hljs-number">20</span>，返回 <span class="hljs-literal">false</span>。<br></code></pre></td></tr></table></figure><p>可以使用两个二分查找进行搜索 </p>]]></content>
    
    
    <categories>
      
      <category>cpp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer-1】面试流程</title>
    <link href="/2022/05/27/%E3%80%90%E5%89%91%E6%8C%87offer-1%E3%80%91%E9%9D%A2%E8%AF%95%E6%B5%81%E7%A8%8B/"/>
    <url>/2022/05/27/%E3%80%90%E5%89%91%E6%8C%87offer-1%E3%80%91%E9%9D%A2%E8%AF%95%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>这是《剑指offer》这本书的总纲，主要总体介绍面试的形式与环节。</p><h1 id="面试形式"><a href="#面试形式" class="headerlink" title="面试形式"></a>面试形式</h1><p>后疫情时代我们现在的面试形式应该就包含电话面试和远程桌面面试。电话面试值得注意的是需要尽可能使用形象化的语言将细节解释清楚，重点是远程桌面面试。</p><h2 id="远程桌面面试"><a href="#远程桌面面试" class="headerlink" title="远程桌面面试"></a>远程桌面面试</h2><p>这种形式的面试，面试官最关心应聘者的编程习惯于调试能力。</p><p>良好的编程习惯：</p><ul><li>思考清楚之后再开始写代码：首先需要先问清楚题目，想清楚思路，在写代码的过程中需注意有哪些特殊情况需要处理（如特殊的输入，边界条件等）；</li><li>良好的代码命名和缩进对齐习惯：我现在在<code>cpp</code>上使用的主要是驼峰命名法，而在python上使用的主要是下划线命名法；</li><li>能够进行单元测试：尽量先考虑特殊的输入，再写单元函数；</li></ul><p>良好的调试能力：</p><ul><li>设置断点</li><li>单步跟踪</li><li>查看内存</li><li>分析调用栈</li></ul><h1 id="面试的环节"><a href="#面试的环节" class="headerlink" title="面试的环节"></a>面试的环节</h1><p>一般面试会有好几面，我们这里主要针对的是技术面。</p><h2 id="行为面试"><a href="#行为面试" class="headerlink" title="行为面试"></a>行为面试</h2><p>行为面试主要集中在面试刚开始的5-10分钟，面试官会在这个阶段注意应聘者的性格特点，深入的了解简历中列举的项目经历。一般在面试刚开始会有一个自我介绍，这个自我介绍主要是用来给面试官熟悉简历，以及暖场的作用，我们准备自我介绍时准备差不多30s-1min的就差不多了，在介绍项目经验时，应该不要将具体的项目细节，应主要突出自己完成的工作于取得的成绩。</p><h3 id="项目经验"><a href="#项目经验" class="headerlink" title="项目经验"></a>项目经验</h3><p>在简历里面可以采用STAR模型来描述自己经历的项目：</p><ul><li>(Situation)简短的项目背景：如项目的规模，软件的功能，目标用户等；</li><li>(Task)自己完成的任务：注意参与和负责两个词的使用；</li><li>(Action)为完成工作自己做了哪些工作，是怎么做的：基于什么工具在哪个平台上应用了哪些技术；</li><li>(Result)自己的贡献：尽量用数字体现。</li></ul><p>如果应聘者描述的不够清晰，面试官可能会追问相关的问题，除此之外，面试官还有一些常温的问题：</p><ul><li>你在该项目中遇到的最大的问题是什么？怎么解决的？</li><li>你在这个项目里面学到了什么？</li><li>什么时候会与其他团队成员有什么样的冲突，怎么解决的？<h3 id="掌握的技能"><a href="#掌握的技能" class="headerlink" title="掌握的技能"></a>掌握的技能</h3>在写掌握的技能时注意了解，熟悉与精通的用词。了解一般指对某项技术只是上过课或者看过书，但没有做过实际的项目。熟悉指在实际项目中我们已经使用某项技术较长的时间，能够通过查阅相关的文档独立的解决大部分问题了；精通一般不写。<h2 id="技术面试"><a href="#技术面试" class="headerlink" title="技术面试"></a>技术面试</h2>技术面一般会持续40-50分钟，面试官总体会注意应聘者以下5个方面的素质：</li><li>扎实的基础知识：<ul><li>编程语言：准备至少两种编程语言</li><li>数据结构：主要需要熟悉链表和二叉树</li><li>算法：主要需要熟悉查找（二分查找）和排序（归并排序和快速排序），有的还需要熟悉动态规划和贪心算法</li></ul></li><li>高质量的代码：需要格外注意边界条件和特殊输入的情况；</li><li>清晰的思路：一般在问题比较复杂时，需要在短时间内形成清晰的思路。<ul><li>可以举几个简单的具体的例子来让自己理解问题</li><li>可以试着用图形来表示抽象的数据结构（如在分析链表和二叉树相关的题目的时候）</li><li>尝试把复杂的问题拆解成若干简单的子问题，再来一一解决</li></ul></li><li>优化效率的能力：<ul><li>要知道如何分析效率：这就要对各种方法的实现效率心中有数</li><li>要熟知各种数据结构的优缺点，并能够选择合适的数据结构来解决问题</li><li>要掌握常用的算法：如查找，排序</li></ul></li><li>优秀的综合能力：<h2 id="提问环节"><a href="#提问环节" class="headerlink" title="提问环节"></a>提问环节</h2></li><li>不要问和自己职位无关的问题</li><li>不要问薪水</li><li>不要立即打听面试结果</li></ul>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>刷题笔记</title>
    <link href="/2022/05/27/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/05/27/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>这是刷题计划的《剑指offer》篇开始，以此篇作为刷题的开始。</p>]]></content>
    
    
    <categories>
      
      <category>cpp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/05/27/hello-world/"/>
    <url>/2022/05/27/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
