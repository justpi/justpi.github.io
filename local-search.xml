<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【剑指offer-2】基础知识</title>
    <link href="/2022/05/28/%E3%80%90%E5%89%91%E6%8C%87offer-2%E3%80%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/05/28/%E3%80%90%E5%89%91%E6%8C%87offer-2%E3%80%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="编程语言"><a class="markdownIt-Anchor" href="#编程语言"></a> 编程语言</h1><p>在面试过程中，面试官要么直接问语法，要么让用一种语言解决一个问题。在cpp中，一般考察编程语言的方式有以下三种：</p><ul><li>直接询问对cpp概念的理解：如cpp中的关键字，或者sizeof函数在各种情况下的值；</li><li>分析写好的代码</li><li>定义一个类型或实现类型中的成员函数</li></ul><h2 id="1赋值运算符函数"><a class="markdownIt-Anchor" href="#1赋值运算符函数"></a> #1赋值运算符函数</h2><blockquote><p>题目：如下为类型CMyString的声明，请为该类型添加赋值运算符函数。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CMyString</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">CMyString</span>(<span class="hljs-type">char</span>* pData=<span class="hljs-literal">nullptr</span>);<br>        <span class="hljs-built_in">CMyString</span>(<span class="hljs-type">const</span> CMyString&amp; str);<br>        ~<span class="hljs-built_in">CMyString</span>(<span class="hljs-type">void</span>);<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">char</span>* m_pData;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在设计赋值运算符函数时需要考虑下面四个问题：</p><ul><li>返回值的类型声明与返回值：返回值的类型声明应该是该类型的引用，返回值应该是返回的实例自身的引用(*this)。考虑连续赋值的情况，如果函数返回值为空，不是返回的引用将不能连续赋值；</li><li>传入的参数类型：传入的参数应该是常量引用，因为如果传入的参数不是引用而是实例的话，那么从形参到实参会调用一次复制构造函数，一般参数传递时使用引用来代替实例和指针，可以避免无谓的消耗，提高代码的效率，另外由于我们在函数中不用改变传入实例的状态，所以使用const；</li><li>内存管理：是否释放实例自身已有的内存；</li><li>特殊输入判断：判断传入的参数和当前的实例(*this)是不是同一个实例；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">CMyString&amp; <span class="hljs-title">CMystring</span><span class="hljs-params">(<span class="hljs-type">const</span> CMyString &amp;str)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (*<span class="hljs-keyword">this</span> == &amp;str) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br><br>    <span class="hljs-keyword">delete</span> []m_pData;<br>    m_pData = <span class="hljs-literal">nullptr</span>;<br><br>    m_pData= <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str.m_pData) + <span class="hljs-number">1</span>]<br>    <span class="hljs-built_in">strcpy</span>(m_pData, str.m_pData);<br><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="cpp基础知识"><a class="markdownIt-Anchor" href="#cpp基础知识"></a> cpp基础知识</h3><blockquote><p><strong>引用</strong>：引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。我们一般在类型名后添加<code>&amp;</code>来表示。</p></blockquote><blockquote><p><strong>引用与指针的区别</strong>：不存在空引用。引用必须连接到一块合法的内存。一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。引用必须在创建时被初始化。指针可以在任何时间被初始化。</p></blockquote><blockquote><p><strong>this指针</strong>：在 C++ 中，每一个对象都能通过 this 指针来访问自己的地址。this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针。</p></blockquote><blockquote><p><strong>复制构造函数</strong>：拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于：通过使用另一个同类型的对象来初始化新创建的对象。复制对象把它作为参数传递给函数。复制对象，并从函数返回这个对象。</p></blockquote><blockquote><p><strong>形参与实参的区别</strong>：形参出现在函数定义的地方，多个形参之间以逗号分隔，形参规定了一个函数所接受数据的类型和数量。实参出现在函数调用的地方，实参的数量与类型与形参一样，实参用于初始化形参。当形参是引用类型时，对应的实参被引用传递，引用形参是对应的实参的别名。当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象，对应的实参被值传递。C++中，建议使用引用类型的形参替代指针，因为使用引用，形式上更简单，无须额外声明指针变量，也避免了拷贝指针的值。如果函数无须改变引用  形参的值，最好将其声明为const引用。</p></blockquote><blockquote><p><strong>指针运算符</strong>：C++ 提供了两种指针运算符，一种是取地址运算符<code>&amp;</code>，一种是间接寻址运算符<code>*</code>。<code>&amp;</code>是一元运算符，返回操作数的内存地址。第二个运算符是间接寻址运算符<code>*</code>，它是<code>&amp;</code>运算符的补充。<code>*</code>是一元运算符，返回操作数所指定地址的变量的值。</p></blockquote><hr /><h1 id="基本数据结构"><a class="markdownIt-Anchor" href="#基本数据结构"></a> 基本数据结构</h1><h2 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h2><blockquote><p>剑指 Offer 03. 数组中重复的数字：在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p></blockquote><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：<br><span class="hljs-string">[2, 3, 1, 0, 2, 5, 3]</span><br>输出：<span class="hljs-number">2</span> 或 <span class="hljs-number">3</span> <br></code></pre></td></tr></table></figure><p>这个问题有三种解法，第一种是先将数组排序，然后从前往后遍历一遍即可找到重复的数，排序的时间复杂度为<code>O(nlogn)</code>；第二种是利用哈希表来解决时间和空间复杂度均为O(n)，如下，还可以进一步不用新建数组，直接在原始数组上交换元素并进行比较，空间复杂度可以到<code>O(1)</code>；第三种是使用二分查找的思想，分别统计前1~m和m+1~n中数字出现的次数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mrow><mn>1</mn><mo separator="true">,</mo><mi>m</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{1,m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mrow><mi>m</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{m+1,n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>，若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mrow><mn>1</mn><mo separator="true">,</mo><mi>m</mi></mrow></msub><mo>&gt;</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">t_{1,m} &gt; m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>则前面的序列中存在重复数字，递归前面的子数组，后面的亦然如此，这种方法每次需要统计数字出现的次数，时间复杂度为<code>O(n)</code>，二分查找时间复杂度为<code>O(logn)</code>，总体时间复杂度为<code>O(nlogn)</code>，空间复杂度为<code>O(1)</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 解法二：数组作为哈希表，空间复杂度为O(n),时间复杂度为O(n)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">hash</span><span class="hljs-params">(nums.size(), <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            hash[nums[i]] ++;<br>            <span class="hljs-keyword">if</span> (hash[nums[i]] &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">测试用例：<br><span class="hljs-bullet">    -</span> 长度为n的数组里包含一个或多个重复的数字<br><span class="hljs-bullet">    -</span> 无效输入测试用例（空数组，包含0——n-1之外的数字）<br></code></pre></td></tr></table></figure><blockquote><p>剑指 Offer 04. 二维数组中的查找:在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">现有矩阵 matrix 如下：<br><span class="hljs-string">[</span><br><span class="hljs-string">  [1,   4,  7, 11, 15]</span>,<br><span class="hljs-string">  [2,   5,  8, 12, 19]</span>,<br><span class="hljs-string">  [3,   6,  9, 16, 22]</span>,<br><span class="hljs-string">  [10, 13, 14, 17, 24]</span>,<br><span class="hljs-string">  [18, 21, 23, 26, 30]</span><br>]<br><br>给定 target = <span class="hljs-number">5</span>，返回 <span class="hljs-literal">true</span>。<br><br>给定 target = <span class="hljs-number">20</span>，返回 <span class="hljs-literal">false</span>。<br></code></pre></td></tr></table></figure><p><strong>思路</strong>：由于数组元素是递增的，那么每访问一个元素，可以排除数组中的部分元素，即从数组的右上角开始遍历，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><msub><mi>s</mi><mrow><mi>r</mi><mi>o</mi><mi>w</mi><mo separator="true">,</mo><mi>c</mi><mi>o</mi><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">nums_{row, col}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>为当前值，当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo>&gt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><msub><mi>s</mi><mrow><mi>r</mi><mi>o</mi><mi>w</mi><mo separator="true">,</mo><mi>c</mi><mi>o</mi><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">target &gt; nums_{row, col}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><msub><mi>s</mi><mrow><mi>r</mi><mi>o</mi><mi>w</mi><mo separator="true">,</mo><mi>c</mi><mi>o</mi><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">nums_{row, col}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>需变为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><msub><mi>s</mi><mrow><mi>r</mi><mi>o</mi><mi>w</mi><mo separator="true">,</mo><mi>c</mi><mi>o</mi><mi>l</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">nums_{row, col-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>，数组第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>o</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">col</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>列可以排除掉；而当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo>&lt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><msub><mi>s</mi><mrow><mi>r</mi><mi>o</mi><mi>w</mi><mo separator="true">,</mo><mi>c</mi><mi>o</mi><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">target &lt; nums_{row, col}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>时，需变为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><msub><mi>s</mi><mrow><mi>r</mi><mi>o</mi><mi>w</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>c</mi><mi>o</mi><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">nums_{row+1, col}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>，数组第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>o</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">row</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>行可以排除掉。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (matrix.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> row = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> col = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (row &lt; matrix.<span class="hljs-built_in">size</span>()  &amp;&amp; col &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> nums = matrix[row][col];<br>            <span class="hljs-keyword">if</span> (nums == target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums &gt; target) col--;  <span class="hljs-comment">// 去掉第col列</span><br>            <span class="hljs-keyword">else</span> row++; <span class="hljs-comment">//去掉第row行</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">测试用例<br><span class="hljs-bullet">    -</span> 正常输入的二维数组，正常的target<br><span class="hljs-bullet">    -</span> 特殊输入测试（输入空数组）<br></code></pre></td></tr></table></figure><h2 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h2><p>C<ins>中每个字符串都以字符<code>'\0'</code>作为结尾，所以每个字符串会有一个额外的内存开销，容易引起内存越界的情况。为节省内存，C</ins>会将常量字符串放到单独的一个内存区域，此时如果使用指针指向它的话，无论多少指针，指向的都是相同的地址。</p><blockquote><p>剑指 Offer 05. 替换空格:请实现一个函数，把字符串 s 中的每个空格替换成&quot;%20&quot;。</p></blockquote><blockquote><p>输入：s = “We are happy.”<br />输出：“We%20are%20happy.”</p></blockquote><p><strong>思路</strong>：两种方法，第一种是暴力求解，即从头到尾遍历一遍，每发现一个空格，就在结尾添加两个元素，然后将空格后的字符串向后移动两个位置，再将<code>'%20'</code>插入字符串中，如下面<code>暴力解法</code>所示，这种方法的时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，空间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，观察可以发现后面的字符串移动了多次，这种时间消耗应该是可以避免的；第二种方法是采用双指针求解，使用<code>p1</code>指针倒序遍历原始字符串，使用<code>p2</code>指针倒序遍历新字符串，当<code>p1</code>指向空格是，<code>p2</code>顺序填入<code>02%</code>，这种方法的时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，但空间复杂度也为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 暴力解法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">replaceSpace</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                s += <span class="hljs-string">&#x27; &#x27;</span>;<br>                s += <span class="hljs-string">&#x27; &#x27;</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-3</span>; j &gt;i; j--) &#123;<br>                    s[j + <span class="hljs-number">2</span>] = s[j];<br>                &#125;<br>                s[i] = <span class="hljs-string">&#x27;%&#x27;</span>;<br>                s[i+<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                s[i+<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 双指针解法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">replaceSpace</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> numspace = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> p1 = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (p1 == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> s;<br>        <span class="hljs-type">int</span> p2;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27; &#x27;</span>) numspace++;<br>        &#125;<br>        p2 = p1 + numspace*<span class="hljs-number">2</span>;<br>        <span class="hljs-function">string <span class="hljs-title">res</span><span class="hljs-params">(p2, <span class="hljs-string">&#x27; &#x27;</span>)</span></span>;<br>        p2 = p2 - <span class="hljs-number">1</span>;<br>        p1 = p1 - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (p1 &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (s[p1] != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                res[p2] = s[p1];<br>                p2--;<br>                p1--;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                res[p2] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                res[p2<span class="hljs-number">-1</span>] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                res[p2<span class="hljs-number">-2</span>] = <span class="hljs-string">&#x27;%&#x27;</span>;<br>                p2 = p2 <span class="hljs-number">-3</span>;<br>                p1--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="链表"><a class="markdownIt-Anchor" href="#链表"></a> 链表</h2><blockquote><p>剑指 Offer 06. 从尾到头打印链表</p></blockquote><blockquote><p>输入：head = [1,3,2]<br />输出：[2,3,1]</p></blockquote><p><strong>思路</strong>：考虑两种方法，第一种需要修改链表结构，即先反转链表，然后再从头到尾进行打印这种方法的时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>， 空间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>；第二种不需修改链表结构，可以递归的打印链表节点，考虑采用链表的后序遍历方法，这种方法的时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，空间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，另外还可采用栈作为一个额外的存储结构，便于我们遍历，下面我们采用后序遍历的方法进行遍历。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 后序遍历求解</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">reversePrint</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-built_in">reverseList</span>(head);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-built_in">reverseList</span>(head -&gt; next);<br>        res.<span class="hljs-built_in">push_back</span>(head -&gt; val);<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="树"><a class="markdownIt-Anchor" href="#树"></a> 树</h2><blockquote><p>剑指 Offer 07. 重建二叉树:输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。<br />假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p></blockquote><blockquote><p>Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]<br />Output: [3,9,20,null,null,15,7]</p></blockquote><p><strong>思路</strong>：此题是一个典型的问题，根据前序遍历和中序遍历的特点，我们可以递归的处理这个问题，首先根据前序遍历找到根节点，然后在前序遍历和中序遍历中划分左右子树，直到子树为空，此方法的时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，空间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p><p>具体构造思路：考虑参数上，我们需要当前的根节点，前序遍历的low与high，中序遍历的low与high，返回值需要返回构造完成之后的根节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 递归解法 -- <span class="hljs-doctag">TODO:</span>此解法在边界上还有一点问题，后续需fix</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">buildSubTree</span>(preorder, <span class="hljs-number">0</span>, preorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, inorder, <span class="hljs-number">0</span>, inorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildSubTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;preorder, <span class="hljs-type">int</span> prelow, <span class="hljs-type">int</span> prehigh, vector&lt;<span class="hljs-type">int</span>&gt; &amp;inorder, <span class="hljs-type">int</span> inlow, <span class="hljs-type">int</span> inhigh)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (prelow &gt; prehigh) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span> (inlow &gt; inhigh) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        TreeNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[prelow]);<br>       <br>        <span class="hljs-type">int</span> inhead=INT_MAX, preright=INT_MAX;<br>        <span class="hljs-comment">// 中序遍历中head节点位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=inlow; i &lt;= inhigh; i++) &#123;<br>            <span class="hljs-keyword">if</span> (inorder[i] == preorder[prelow]) &#123;<br>                inhead = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 前序遍历中左子树最后一个节点位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=prelow; i &lt;= prehigh; i++) &#123;<br>            <span class="hljs-keyword">if</span> (inorder[inhead - <span class="hljs-number">1</span>] == preorder[i]) &#123;<br>                preright=i+<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; preright &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; inhead &lt;&lt; endl;<br>        head -&gt; left = <span class="hljs-built_in">buildSubTree</span>(preorder, prelow+<span class="hljs-number">1</span>, preright - <span class="hljs-number">1</span>, inorder, inlow, inhead - <span class="hljs-number">1</span>);<br>        head -&gt; right = <span class="hljs-built_in">buildSubTree</span>(preorder, preright, prehigh, inorder, inhead + <span class="hljs-number">1</span>, inhigh);<br>       <br>        <br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="栈与队列"><a class="markdownIt-Anchor" href="#栈与队列"></a> 栈与队列</h2><blockquote><p>剑指 Offer 09. 用两个栈实现队列:用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p></blockquote><blockquote><p>输入：<br />[“CQueue”,“appendTail”,“deleteHead”,“deleteHead”]<br />[[],[3],[],[]]<br />输出：[null,null,3,-1]</p></blockquote><p><strong>思路</strong>：考察栈与队列的特性，在插入操作中，我们先将序列<code>push</code>到<code>#1</code>栈中，然后从<code>#1</code>中<code>pop</code>出来<code>push</code>到<code>#2</code>栈中，这样就完成了一个序列的颠倒；在删除操作中，我们简单的<code>pop</code>出<code>#2</code>栈中的数据即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CQueue</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CQueue</span>() &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">appendTail</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        stack1.<span class="hljs-built_in">push</span>(value);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">deleteHead</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (stack2.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (stack1.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            <span class="hljs-built_in">in2out</span>();<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> res = stack2.<span class="hljs-built_in">top</span>();<br>        stack2.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> res;<br>        <br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; stack1, stack2;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">in2out</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(!stack1.<span class="hljs-built_in">empty</span>()) &#123;<br>            stack2.<span class="hljs-built_in">push</span>(stack1.<span class="hljs-built_in">top</span>());<br>            stack1.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="算法与数据操作"><a class="markdownIt-Anchor" href="#算法与数据操作"></a> 算法与数据操作</h1><p>查找与排序应重点掌握<code>二分查找</code>，<code>归并排序</code>，<code>快速排序</code>。</p><p>二维数组中搜索路径，可以尝试回溯算法，一般回溯算法用递归写会比较方便，而如果不能使用递归，则可以使用栈来模拟递归的过程。</p><p>如果问题是求最优解，且该问题可以分为多个子问题，那么我们可以尝试动态规划，自上而下的思路去处理动态规划的问题。如果动态规划中存在某个特殊的选择，那么可以采用贪婪算法。</p><p>位运算是一种特殊的算法，它是将数字表示成二进制之后对0和1进行操作，其只有与/或/异或/左移/右移5种运算。</p><h2 id="递归与循环"><a class="markdownIt-Anchor" href="#递归与循环"></a> 递归与循环</h2><blockquote><p>剑指 Offer 10- I. 斐波那契数列：写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：F(0) = 0,   F(1) = 1<br />F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p></blockquote><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><blockquote><p>输入：n = 5 输出：5；<br />输入：n = 2 输出：1</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 纯递归解法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">fib</span>(n<span class="hljs-number">-1</span>) + <span class="hljs-built_in">fib</span>(n<span class="hljs-number">-2</span>)) % (<span class="hljs-number">1000000007</span>);<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 动态规划解法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> resN1 = nums[n<span class="hljs-number">-1</span>] == <span class="hljs-number">-1</span> ? <span class="hljs-built_in">fib</span>(n<span class="hljs-number">-1</span>) : nums[n<span class="hljs-number">-1</span>];<br>        <span class="hljs-type">int</span> resN2 = nums[n<span class="hljs-number">-2</span>] == <span class="hljs-number">-1</span> ? <span class="hljs-built_in">fib</span>(n<span class="hljs-number">-2</span>) : nums[n<span class="hljs-number">-2</span>]; <br>        <span class="hljs-keyword">if</span> (nums[n] == <span class="hljs-number">-1</span>) &#123;<br>            nums[n] = (resN1 + resN2) % (<span class="hljs-number">1000000007</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> (resN1 + resN2) % (<span class="hljs-number">1000000007</span>);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; nums=<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; (<span class="hljs-number">1000000007</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 循环+动态规划解法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        nums.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>        nums.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> res1, res2;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i &lt;=n; i++) &#123;<br>            res1 = nums[i<span class="hljs-number">-1</span>];<br>            res2 = nums[i<span class="hljs-number">-2</span>];<br>            nums.<span class="hljs-built_in">push_back</span>((res1 + res2) % (<span class="hljs-number">1000000007</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[n];<br>        <br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; nums;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="查找"><a class="markdownIt-Anchor" href="#查找"></a> 查找</h2><blockquote><p>剑指 Offer 11. 旋转数组的最小数字:把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br />给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为 1。  <br />注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p></blockquote><blockquote><p>输入：numbers = [3,4,5,1,2]<br />输出：1</p></blockquote><p><strong>思路</strong>：可以直接暴力遍历一遍，即可找到要找的值，此方法的时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>；也可以采用二分查找的方法，选择最后一个元素<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>作为基准，可以发现在最小值前面的元素均大于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>，在最小值后面的元素均小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>，这样可以进行二分查找。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; numbers)</span> </span>&#123;<br>        <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> high = numbers.<span class="hljs-built_in">size</span>() <span class="hljs-number">-1</span>;<br>        <br>        <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>            <span class="hljs-type">int</span> p = (low + high) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (numbers[p] &gt; numbers[high]) &#123;<br>                low = p + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numbers[p] &lt; numbers[high])&#123;<br>                high = p;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                high--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> numbers[low];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="回溯法"><a class="markdownIt-Anchor" href="#回溯法"></a> 回溯法</h2><p>解决问题包含许多步骤，每个步骤都有多个选项，此解决方案可以看成一颗树，我们就是遍历这颗树，当某节点不满足约束条件时，则回溯到上一节点再尝试其他选项。</p><blockquote><p>剑指 Offer 12. 矩阵中的路径：给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p></blockquote><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p></p><p>例如，在下面的 3×4 的矩阵中包含单词 “ABCCED”（单词中的字母已标出）。<br /><img src="%E3%80%90%E5%89%91%E6%8C%87offer-2%E3%80%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/12_word2.jpg" alt="image-word2" /></p><blockquote><p>输入：board = [[“A”,“B”,“C”,“E”],[“S”,“F”,“C”,“S”],[“A”,“D”,“E”,“E”]], word = “ABCCED”<br />输出：true</p></blockquote><p><strong>思路</strong>：</p><ul><li><p>递归参数：当前矩阵的行索引<code>i</code>和列索引<code>j</code>，以及<code>word</code>中的索引<code>k</code>；</p></li><li><p>终止条件：</p><ul><li>返回false：行索引越界，列索引越界，当前矩阵元素与目标字符不同，当前矩阵元素已访问过；</li><li>返回true：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi><mi mathvariant="normal">.</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k=word.size() -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord">.</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>；</li></ul></li><li><p>递推工作：</p><ol><li>标记当前矩阵元素：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>o</mi><mi>a</mi><mi>r</mi><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><msup><mo>=</mo><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup></mrow><annotation encoding="application/x-tex">board[i][j]=&#x27;&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>，表示此元素已访问过，防止以后搜索时重复访问；</li><li>搜索下一单元格，有四个方位。使用<code>||</code>进行连接</li></ol></li><li><p>返回值：返回<code>bool</code>值，代表是否搜索到目标字符串。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (board.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || word.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        row = board.<span class="hljs-built_in">size</span>();<br>        col = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j &lt; col; j++) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">backtracking</span>(board, word, i, j, <span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> row, col;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board, string word,<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= row || i &lt; <span class="hljs-number">0</span> || j &gt;= col || j &lt; <span class="hljs-number">0</span> || board[i][j]!=word[k]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (k == word.<span class="hljs-built_in">size</span>() <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        board[i][j] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        <span class="hljs-type">bool</span> res = <span class="hljs-built_in">backtracking</span>(board, word, i<span class="hljs-number">-1</span>, j, k+<span class="hljs-number">1</span>) || <span class="hljs-built_in">backtracking</span>(board, word, i+<span class="hljs-number">1</span>, j ,k+<span class="hljs-number">1</span>) || <span class="hljs-built_in">backtracking</span>(board, word, i, j<span class="hljs-number">-1</span>, k+<span class="hljs-number">1</span>) || <span class="hljs-built_in">backtracking</span>(board, word, i, j+<span class="hljs-number">1</span>, k+<span class="hljs-number">1</span>);<br>        board[i][j] = word[k];<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p></blockquote><blockquote><p>输入：m = 2, n = 3, k = 1<br />输出：3</p></blockquote><p><strong>思路</strong>：此题与上题一样，均使用回溯算法进行求解</p><ul><li>递归参数：矩阵的行索引<code>i</code>与列索引<code>j</code>，以及约束条件<code>k</code>;</li><li>终止条件：<ol><li>返回0：行索引与列索引越界，行索引与列索引突破约束条件；</li><li>返回具体可移动格子数res：</li></ol></li><li>递推工作：<ol><li>标记当前元素：如果当前元素已经被访问过了，就将矩阵值设为1；</li><li>搜索下一步骤：从4个方向寻找，用<code>||</code>进行连接；</li></ol></li><li>返回值：返回<code>res</code>为从该节点出发可到达的格子数；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">board</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br>        row = m; col = n;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">backtracking</span>(board, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, k);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> row, col;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; board, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= row || j &lt; <span class="hljs-number">0</span> || j &gt;= col || !<span class="hljs-built_in">digCompare</span>(i, j, k) || board[i][j] == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        board[i][j] = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> res = <span class="hljs-built_in">backtracking</span>(board, i<span class="hljs-number">-1</span>, j, k) + <span class="hljs-built_in">backtracking</span>(board, i+<span class="hljs-number">1</span>, j, k) + <span class="hljs-built_in">backtracking</span>(board, i, j<span class="hljs-number">-1</span>, k) + <span class="hljs-built_in">backtracking</span>(board, i, j+<span class="hljs-number">1</span>, k) + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">digCompare</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> num1=<span class="hljs-number">0</span>, num2=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i !=<span class="hljs-number">0</span>) &#123;<br>            num1 += i % <span class="hljs-number">10</span>;<br>            i = i / <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span> ( j !=<span class="hljs-number">0</span>) &#123;<br>            num2+= j % <span class="hljs-number">10</span>;<br>            j = j / <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (num1 + num2 &gt; k) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="动态规划与贪心算法"><a class="markdownIt-Anchor" href="#动态规划与贪心算法"></a> 动态规划与贪心算法</h2><p>问题要能分解成若干子问题以及重叠子问题结构，则可采用动态规划进行求解。</p><blockquote><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p></blockquote><blockquote><p>输入: 2<br />输出: 1<br />解释: 2 = 1 + 1, 1 × 1 = 1</p></blockquote><p><strong>思路</strong>：分析动态规划问题的思路，从上往下分别问题（需分析是否能分解成若干子问题， 子问题有无重叠），从下往上求解（使用一个一维或二维数组存放结果）。</p><ul><li>确定dp数组下标意义：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>表示长度为i的绳子的所有连乘积结果的最大值；</li><li>初始化状态：<ol><li>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(i)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>；当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f(i)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>；当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">i=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f(i)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>;</li></ol></li><li>确定状态转移方程：长度为i的绳子在切出长度为j时有三种可能的方案<ol><li>直接相乘，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>⋅</mo><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">j\cdot (i-j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>;</li><li>其中一个继续可分，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>⋅</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">j \cdot dp[i-j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>⋅</mo><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[j] \cdot (i-j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>；</li><li>两者皆可分，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>⋅</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[j] \cdot dp[i-j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>;</li></ol></li><li>遍历顺序：从底向上遍历；<ol><li>i的取值范围：3~n;</li><li>j的取值范围：2~i-1;</li></ol></li><li>返回值：dp[n];</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 动态规划求解</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (n ==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        res[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        res[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        res[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>        res[<span class="hljs-number">3</span>] = <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>; i&lt;= n; i++) &#123;<br>            <span class="hljs-type">int</span> max_num = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">2</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-type">int</span> num = <span class="hljs-built_in">max</span>(&#123;j * (i-j), j * res[i-j], res[j] * (i-j), res[j] * res[i-j]&#125;);<br>                max_num = max_num &gt; num ? max_num: num;<br>            &#125;<br>            res[i] = max_num;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="位运算"><a class="markdownIt-Anchor" href="#位运算"></a> 位运算</h2><p>位运算主要有与，或，异或以及左移，右移这五种运算。其中右移有一点特殊，对于有符号数，右移后左边的值需补其符号位，若为正数，则全补0，负数则全补1；</p><blockquote><p>剑指 Offer 15. 二进制中1的个数:编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 汉明重量).）。</p></blockquote><blockquote><p>输入：n = 11 (控制台输入 00000000000000000000000000001011)<br />输出：3<br />解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。</p></blockquote><p><strong>思路</strong>：每一位与0做异或，结果为1则为1，结果为0则为0；也可以与1做与运算，结果为0则为0，结果为1则为1；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 与运算</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">uint32_t</span> flag=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(flag) &#123;<br>            <span class="hljs-keyword">if</span> (n &amp; flag) count++;<br>            flag = flag &lt;&lt; <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>cpp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer-1】面试流程</title>
    <link href="/2022/05/27/%E3%80%90%E5%89%91%E6%8C%87offer-1%E3%80%91%E9%9D%A2%E8%AF%95%E6%B5%81%E7%A8%8B/"/>
    <url>/2022/05/27/%E3%80%90%E5%89%91%E6%8C%87offer-1%E3%80%91%E9%9D%A2%E8%AF%95%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>这是《剑指offer》这本书的总纲，主要总体介绍面试的形式与环节。</p><h1 id="面试形式"><a class="markdownIt-Anchor" href="#面试形式"></a> 面试形式</h1><p>后疫情时代我们现在的面试形式应该就包含电话面试和远程桌面面试。电话面试值得注意的是需要尽可能使用形象化的语言将细节解释清楚，重点是远程桌面面试。</p><h2 id="远程桌面面试"><a class="markdownIt-Anchor" href="#远程桌面面试"></a> 远程桌面面试</h2><p>这种形式的面试，面试官最关心应聘者的编程习惯于调试能力。</p><p>良好的编程习惯：</p><ul><li>思考清楚之后再开始写代码：首先需要先问清楚题目，想清楚思路，在写代码的过程中需注意有哪些特殊情况需要处理（如特殊的输入，边界条件等）；</li><li>良好的代码命名和缩进对齐习惯：我现在在<code>cpp</code>上使用的主要是驼峰命名法，而在python上使用的主要是下划线命名法；</li><li>能够进行单元测试：尽量先考虑特殊的输入，再写单元函数；</li></ul><p>良好的调试能力：</p><ul><li>设置断点</li><li>单步跟踪</li><li>查看内存</li><li>分析调用栈</li></ul><h1 id="面试的环节"><a class="markdownIt-Anchor" href="#面试的环节"></a> 面试的环节</h1><p>一般面试会有好几面，我们这里主要针对的是技术面。</p><h2 id="行为面试"><a class="markdownIt-Anchor" href="#行为面试"></a> 行为面试</h2><p>行为面试主要集中在面试刚开始的5-10分钟，面试官会在这个阶段注意应聘者的性格特点，深入的了解简历中列举的项目经历。一般在面试刚开始会有一个自我介绍，这个自我介绍主要是用来给面试官熟悉简历，以及暖场的作用，我们准备自我介绍时准备差不多30s-1min的就差不多了，在介绍项目经验时，应该不要将具体的项目细节，应主要突出自己完成的工作于取得的成绩。</p><h3 id="项目经验"><a class="markdownIt-Anchor" href="#项目经验"></a> 项目经验</h3><p>在简历里面可以采用STAR模型来描述自己经历的项目：</p><ul><li>(Situation)简短的项目背景：如项目的规模，软件的功能，目标用户等；</li><li>(Task)自己完成的任务：注意参与和负责两个词的使用；</li><li>(Action)为完成工作自己做了哪些工作，是怎么做的：基于什么工具在哪个平台上应用了哪些技术；</li><li>(Result)自己的贡献：尽量用数字体现。</li></ul><p>如果应聘者描述的不够清晰，面试官可能会追问相关的问题，除此之外，面试官还有一些常温的问题：</p><ul><li>你在该项目中遇到的最大的问题是什么？怎么解决的？</li><li>你在这个项目里面学到了什么？</li><li>什么时候会与其他团队成员有什么样的冲突，怎么解决的？</li></ul><h3 id="掌握的技能"><a class="markdownIt-Anchor" href="#掌握的技能"></a> 掌握的技能</h3><p>在写掌握的技能时注意了解，熟悉与精通的用词。了解一般指对某项技术只是上过课或者看过书，但没有做过实际的项目。熟悉指在实际项目中我们已经使用某项技术较长的时间，能够通过查阅相关的文档独立的解决大部分问题了；精通一般不写。</p><h2 id="技术面试"><a class="markdownIt-Anchor" href="#技术面试"></a> 技术面试</h2><p>技术面一般会持续40-50分钟，面试官总体会注意应聘者以下5个方面的素质：</p><ul><li>扎实的基础知识：<ul><li>编程语言：准备至少两种编程语言</li><li>数据结构：主要需要熟悉链表和二叉树</li><li>算法：主要需要熟悉查找（二分查找）和排序（归并排序和快速排序），有的还需要熟悉动态规划和贪心算法</li></ul></li><li>高质量的代码：需要格外注意边界条件和特殊输入的情况；</li><li>清晰的思路：一般在问题比较复杂时，需要在短时间内形成清晰的思路。<ul><li>可以举几个简单的具体的例子来让自己理解问题</li><li>可以试着用图形来表示抽象的数据结构（如在分析链表和二叉树相关的题目的时候）</li><li>尝试把复杂的问题拆解成若干简单的子问题，再来一一解决</li></ul></li><li>优化效率的能力：<ul><li>要知道如何分析效率：这就要对各种方法的实现效率心中有数</li><li>要熟知各种数据结构的优缺点，并能够选择合适的数据结构来解决问题</li><li>要掌握常用的算法：如查找，排序</li></ul></li><li>优秀的综合能力：</li></ul><h2 id="提问环节"><a class="markdownIt-Anchor" href="#提问环节"></a> 提问环节</h2><ul><li>不要问和自己职位无关的问题</li><li>不要问薪水</li><li>不要立即打听面试结果</li></ul>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>刷题笔记</title>
    <link href="/2022/05/27/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/05/27/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>这是刷题计划的《剑指offer》篇开始，以此篇作为刷题的开始。</p>]]></content>
    
    
    <categories>
      
      <category>cpp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/05/27/hello-world/"/>
    <url>/2022/05/27/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
